# chapter 02 一切都是对象

## 用引用操纵对象

- 使用标识符操纵一个对象,实际上这个标识符是对象的一个"引用".想要操纵一个词或句子,可以创建一个String引用

```java
String s;
```

这里创建的只是引用,并不是对象.如果此时对s发送一个消息,那么就会返回一个运行时的错误.因为此时s并没有与任何事物关联.所以安全的做法应该在创建引用的时候进行初始化.

```java
String s = "abcd";
//此处字符串可以用带引号的文本初始化.
```

---

## 必须由你创建所有对象

- 通常使用new操作符来实现为一个引用创建一个对象相关联.

```java
String s = new String("abcd");
```

###  存储到什么地方

- **寄存器**,最快的存储区,因为它在处理器的内部.同时寄存器的数量有限,所以寄存器会根据需求进行分配.
- **堆栈**,位于通用RAM(随机访问存储器)中,可以通过堆栈指针从处理器那里获得直接支持,指针向下移动则分配新的内存,向上移动,则释放那些内存.需要知道所有项的确切生命周期.对象引用存储于堆栈中,但是Java对象不存在于其中.
- **堆**,一种通用的内存池(位于RAM区),用于存放所有的JAVA对象.不需要知道存储的数据需要存活多长时期.与栈比较,更加灵活,但是牺牲了效率.
- **常量存储**,通常存放在代码内部.永远不会被更改.有时,在嵌入式系统中,常量会和其他部分隔离开.在这种情况下,可以选择存放在ROM(只读存储器)中.
- **非RAM存储**.可以存活于程序之外,不受程序控制.**流对象**和**持久化对象**.这种存储方式的技巧就是将对象转换成可以存放在其他媒介上的事物,在需要的时候,可以恢复成常规的,基于RAM的对象.

### 基本类型

- **存储于堆栈中**,不用new来创建变量,而是创建一个并非是引用的"自动变量",更加高效.
- **存储空间大小不会随机器硬件架构变化而变化**（使Java程序更具可移植性的原因之一）。
- **boolean** 大小没有明确指定，仅定义为能够取字面值true和false。包装类类型**Boolean**。
- **char**，大小16bits，最小值Unicode 0，最大值Unicode 2^16，包装类**Character**。
- **byte**，大小8bits，最小值-128，最大值127，包装类**Byte**。
- **short**,大小16bits，最小值-2^15，最大值2^15-1，包装类**Short**。
- **int**，大小32bits，最小值-2^31，最大值2^31-1，包装类**Integer**。
- **long**，大小64bits，最小值-2^63，最大值2^63-1，包装类**Long**。
- **float**，大小32bits，IEEE754，IEEE754，**Float**。
- **double**，64bits,IEEE754，IEEE754，**Double**。
- 自动包装,Character ch = 'x'。反向装换，char c = ch；
- 两个高精度的类，**BigInteger**和**BigDecimal**。两者没有对应的基本类型。以方法调用的方式取代运算符方式来实现。用速度换取了精度。

### Java中的数组

- Java主要目标之一是安全性，在c或c++中使用数组是很危险的，c和c++的数组就是内存块，如果一个程序要访问其自身内存块之外的数组，或在数组初始化前使用内存，都会产生很严重的后果。
- Java确保数组会被初始化，而且不能再它的范围之外被访问。这种范围检查，是以每个数组上少量的内存开销及运行时的下标检查为代价的。由此换来的是安全性和效率的提高。
- 当创建一个数组对象时，实际上就是创建了一个引用数组，并且每个引用都会自动被初始化为一个特定值，该值拥有自己的关键字null。一旦Java看到null，就知道该引用还没有指向某个对象，如果试图使用一个还是null的引用，在运行时就会报错。

## 永远不需要销毁对象

### 作用域

```c++
//大多数过程性语言都有作用域的概念。作用域决定了在其内定义的变量名的可见性和生命周期。
//以下代码可以在C和C++中运行，但是在Java中不允许。
{
    int x = 12;
    {
        int x = 96;//Illegal
    }
}
```

### 对象的作用域

- Java对象不具备和基本类型一样的生命周期。当用new创建一个对象时，它可以存活于作用域之外。

```java
{
    String s = new String("a String");
}
//此时引用s在作用域终点就消失了。但是s指向的String对象仍继续占据内存空间。此时虽然无法再这个作用域之后访问这个对象（唯一引用已经超出了作用域的范围）。但是在程序执行过程中，可以传递和复制对象引用。
```

- 用new创建的对象，只要你需要可以一直保留下去。为了防止内存空间被占满，Java有一个垃圾回收器，用来监视所有用new创建的所有对象，并辨别哪些是不会再被引用的对象。随后释放这些对象的内存空间，以便其他新的对象使用。

## 创建新的数据数据类型：类

### 字段和方法

- 在Java中你所做的全部工作就是定义类，产生那些类的对象，以及发送消息给这些对象。
- 在类中可以设置两种类型的元素：**字段和方法**。
- 如果类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值。

## 方法、参数和返回值

- **int x = a.f()**.这种调用方法的行为通常被称为发送消息给对象。消息是 f（），对象是a。面向对象的程序设计通常简单地归纳为“向对象发送消息”。

## 构建一个Java程序

### 名字可见性

- 保证每个类都有唯一的标识符。如com.xxx.xxx

### 运用其他构件

- 使用**import**指示编译器导入一个包。

### static关键字

- 使用**static**关键字，保证这个域的方法不会与该类的任何对象实例关联。及时没有创建对象，也可以去访问。

```java
class StaticTest {
    static int i = 47;
}

//创建两个StaticTest对象，StaticTest.i也只有一份存储空间，这两个对象共用一个i。
StaticTest st1 = new StaticTest;
StaticTest st2 = new StaticTest;

//引用static变量
//通过对象 st1.i
//直接通过类名引用 st2.i

//静态方法类似
class Incrementable {
    static void increment() {StaticTest.i++;}
}

Incrementtable sf = new Incrementable();
sf.increment();

Incrementable.increment();
```

### 第一个Java程序

```Java
//HelloDate.Java
import java.util.*;

public class HelloDate {
    public static void main(String[] args) {
        System.out.println("Hello, it's: ");
        System.out.println(new Date());
    }
} 
```

- java.lang 会自动导入到每一个Java文件中
- 你要使用Date类必须导入Import java.util.Date
- 



