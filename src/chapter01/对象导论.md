## chapter No.1 对象导论

### 1.1 面向对象的五个基本特性

- 万物皆为对象

- 程序是对象的集合,他们通过发送消息来告知彼此所要做的
- 每个对象都有自己的有其他对象所构成的存储
- 每个对象都拥有其类型
- 某一特定类型的所有对象都可以接收同样的消息

---

### 1.2 每个对象都有一个接口

- 面向对象程序设计的挑战之一,就是在问题空间的元素和解空间的对象之间创建一对一的映射.
- 接口确定了对某一特定对象所能发出的请求.

---

### 1.3 每个对象都提供服务

- 开发程序时.最好方法就是将对象想象为"服务提供者".
- 将问题分解为对象集合,即将问题从表象总抽取出来.寻找合适的对象去解决问题.
- 提高对象的内聚性,不让一个对象做过多的事情,这样做的好处能够提高对象的复用性.让试图理解你代码的人读代码更简单.

---

### 1.4 被隐藏的具体实现

- 将开发人员分为**类创建者**和**客户端程序员**.类创建者目标是构建类,这种类只向客户端程序员暴露必须的部分,隐藏其他部分.将实现隐藏起来可以减少程序bug.避免被其他人修改.
- **访问控制**.
  - 存在的第一个原因.这些被创建的类并非用户解决问题所需要的,但是确实客户端程序员操作数据类型必要的,对客户端程序员来说,其实这是一项服务.
  - 第二原因,允许库设计者轻松更改类的实现方式而不必担心影响到客户端程序员.
- 类的内部设定中的三个关键字
  - **public**:默认任何人都能访问
  - **private**:除了类的创建者和类内部的方法,其他人都不能访问.像是跟客户端程序员之间的一堵砖墙,如果有人试图访问将会在编译阶段报错.
  - **protected**:和private类似,但是可以被继承的类访问.
  - **默认访问权限(包访问权限)**:可以访问包内的其他类成员,但是对于包外的,这些成员如同指定了private

---

### 1.5 复用具体实现

- 在新的类中填入一个类的对象.这种概念叫做**组合(composition)**.如果这种组合是动态的,通常被称为**聚合(aggregation)**.
- 新类的成员对象通常被声明为**private**,因为这样可以保证成员对象不被客户端程序员访问.

---

### 1.6 继承

- 父类(基类,超类)有所有子类(导出类,继承类)的共性,子类与父类**具有相同的类型**,要使父类和子类有差异,有两种方式,一个是在子类中添加新的方法.另一种方式就是在子类中重新定义父类的方法,这种方式叫做覆盖(overriding).
- "is-a" 和 "is-like-a",子类是否有新加的接口

---

### 1.7 伴随多态的可互换对象

- 直接调用父类的方法,面向对象程序设计使用后期绑定的方法来决定具体的实现方法.JAVA通过特殊的代码代替了以绝对地址访问的方法.这段代码使用对象中存储的信息来计算方法体的地址.在运行时才会被确定.这样做的好处是,在添加新的子类时,通过**向上转型**的方式可以避免修改方法.

---

### 1.8 单根继承结构

- 所有类的继承Object.
- 所有类具有相同的基本类型.在系统中可以在每个对象上执行某些基本操作.所有对象都可以在堆上创建,便于参数的传递.
- 使得垃圾回收机制变得简单.又有对象都保证有其基本信息,不会因为类型不确定而陷入僵局.这对于系统级操作(如异常处理)显得尤为重要.

---

### 1.9 容器

- 不同容器对不同操作的效率不同.比如ArrayList和LInkedList.arrayList随机访问元素的时间是固定的,而linkedList访问元素需要在列表中移动,越靠后需要的时间越长.然而在列表中插入某个元素,LinkedList又要比ArrayList开销要小.
- **参数化类型**,简单来说就是泛型<>,通过泛型可以使容器中的被转换成Object的对象正确的向下转型成原本的类型.对容器进行定制化处理.

---

### 2.0 对象的创建和生命期

- JAVA完全采用了动态内存分配方式,在堆(heap)的内存池中动态的创建对象,直到运行的时候才知道需要多少对象.而C++为了追求最大的执行速度,对象的存储空间和生命周期可以在编写程序时确定,这样牺牲了灵活性
- Java对象的生命周期是通过垃圾回收器自动发现对象何时不再使用并销毁,这可以避免C++的内存泄漏问题







